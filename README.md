# kotlin_practice

## 기술 스택
- Kotlin 1.9.x
- Spring Boot 3.x.x
- PostgreSQL 15.8

## 실행 방법

### 1) 데이터베이스 실행
```bash
# Windows PowerShell
# 프로젝트 루트 경로에서 실행
docker compose up -d
```

### 2) OpenAI API Key 설정
```powershell
$env:OPENAI_API_KEY="sk-..."
```

### 3) 애플리케이션 실행
```bash
./gradlew bootRun
```

기본 주소: `http://localhost:8080`

## Swagger / OpenAPI
- OpenAPI 명세: `/v3/api-docs`
- Swagger UI: `/swagger-ui/index.html`

## 1. 과제를 어떻게 분석하였나요?

과제를 분석하는 과정은 단순히 기능을 구현 목록으로 나누는 것이 아니라,  
주어진 요구사항과 상황을 빠르게 이해하고 **제한된 시간 안에서 완성 가능한 MVP를 만드는 전략을 세우는 것**에 초점을 두었습니다.

먼저 전체 요구사항을 처음부터 끝까지 한 번 읽으며 시스템의 전체 흐름을 파악하였고,  
구현 난이도가 높거나 설계 판단이 필요한 영역을 별도로 표시하여 우선순위를 정했습니다.

특히 다음 항목들을 핵심 리스크로 판단하였습니다.

- Thread 자동 생성/유지 규칙
- SSE 스트리밍 처리
- 인증/권한(RBAC)
- 동시성 처리

이후 시간 분배를 통해 단계적으로 진행하였습니다.

### 타임 테이블
- 2:00 ~ 2:20 요구사항 분석 및 설계 방향 결정
- 2:20 ~ 3:30 AI 활용 기능 구현
- 3:30 ~ 4:00 End-to-End 테스트 및 리팩토링
- 4:00 ~ 4:50 문서화 및 정리

또한 단기 구현에만 집중하지 않고 **확장 가능성도 함께 고려**하였습니다.  
예를 들어 “향후 대외비 문서를 학습시키고 싶다”는 요구를 보고, 장기적으로 RAG 기반 구조가 필요할 수 있다고 판단하여 AI 호출 레이어를 `AiClient` 인터페이스로 추상화해 provider 교체 및 컨텍스트 확장이 가능하도록 설계하였습니다.

---

## 2. 과제 진행 시 AI를 어떻게 활용하였나요? 어떤 어려움이 있었나요?

### 활용 방식

AI를 단순 코드 생성 도구가 아니라 **구현을 보조하는 엔지니어 역할**로 활용하였습니다.

다음과 같은 반복 사이클로 개발을 진행하였습니다.

1. GPT로 요구사항을 구조화하고 Codex에 최적화된 프롬프트 작성
2. Codex CLI로 보일러플레이트 및 기본 구현 생성
3. Gemini로 코드 품질/취약점/설계 적절성 검증
4. 직접 코드 리뷰 및 Postman 테스트 수행
5. approve 또는 reject 후 필요한 부분만 반영

즉,
- AI → 코드 생성 및 1차 검토
- 저 → 설계 판단 및 최종 승인

의 구조로 역할을 분리하여 생산성을 높였습니다.

### 역할 분리

#### AI
- 반복 코드/CRUD/엔티티/설정 작성
- 확정된 비즈니스 로직 구현
- 취약점 및 개선점 분석

#### 저
- 요구사항 해석 및 범위 정의
- 아키텍처 설계
- 기술 선택
- 확장성/보안 검토
- 최종 의사결정

특히 불필요한 추상화, 과도한 레이어 분리, 오버 엔지니어링이 제안될 경우 즉시 reject하고 요구사항을 다시 설명하여 재작성하도록 하였습니다.

### 어려웠던 점

- AI가 요구사항 범위를 넘어 스스로 아키텍처 결정을 내리는 경우가 있었습니다.
- 생성된 코드를 그대로 신뢰할 수 없어 지속적인 수동 검증이 필요했습니다.
- 확장성과 구현 속도 사이의 트레이드오프를 판단하는 과정이 가장 어려웠습니다.

따라서 AI는 생산성 도구로 활용하되, 설계와 책임은 직접 가져가는 방식으로 진행하였습니다.

---

## 3. 구현하기 가장 어려웠던 기능

### 1) 스트리밍(SSE)과 트랜잭션 경계

#### 문제
SSE는 응답을 즉시 시작하는 구조이므로, 기존 트랜잭션이 먼저 종료됩니다.  
스트리밍 완료 이후 비동기 스레드에서 DB 저장을 수행하면 트랜잭션이 없는 상태가 되어 예외 처리 및 롤백이 어려운 문제가 있었습니다.

#### 해결
DB 저장 로직을 별도의 `ChatPersistenceService`로 분리하고 `@Transactional`을 적용하였습니다.  
스트리밍 완료 후 새 트랜잭션에서 chat 저장 및 thread 갱신이 수행되도록 구조를 변경하였습니다.

#### 선택 이유
- 트랜잭션 경계 명확
- 비동기 환경에서도 안전
- 책임 분리로 유지보수성 향상

---

### 2) 스레드 생성 동시성 이슈

#### 문제
동일 사용자가 동시에 요청을 보내는 경우, 두 요청이 동시에 “만료된 스레드”로 판단하여 중복 스레드가 생성되는 경쟁 상태가 발생할 수 있었습니다.

#### 해결
사용자 기준 **비관적 잠금(PESSIMISTIC_WRITE)**을 적용하여 스레드 생성 로직을 직렬화하였습니다.

동작 방식:
- 첫 요청이 잠금 획득 후 생성/갱신
- 두 번째 요청 대기
- 최신 상태 기준 재사용

#### 선택 이유
- DB 레벨에서 안전
- 멀티 인스턴스 환경에서도 일관성 보장
- 구현 단순성 및 안정성 측면에서 최적

---

위와 같은 방식으로  
요구사항 분석 → AI 활용 구현 → 수동 검증 → 안정성 보완의 과정을 반복하며 과제를 수행하였습니다.
